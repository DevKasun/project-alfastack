---
alwaysApply: true
---

Project Development Guidelines for AI SaaS Landing Page
This document outlines a set of best practices and "rules" to follow while developing your single-page landing site for an AI SaaS product, inspired by the provided assignment brief. Adhering to these guidelines will help ensure a high-quality, maintainable, and visually engaging solution.

1. Project Setup & Structure
   Framework: Utilize Next.js (App Router), which is an excellent choice for a modern React application, offering features like file-system based routing and server components.

Styling: Implement styling exclusively with Tailwind CSS. Leverage its utility-first approach for rapid and consistent styling, and its responsive prefixes (sm:, md:, lg:) for adaptive design.

Folder Structure: Maintain a clear and modular folder structure, typical for Next.js App Router projects.

app/: (This is your main application directory for the App Router)

layout.js: Root layout for your application.

page.js: Your main landing page component.

globals.css: Global styles, including Tailwind CSS imports.

components/: Reusable UI components (e.g., Button.js, Navbar.js).

sections/: Each of the five main sections of your landing page (e.g., Hero.js, WhoWeAre.js, TransformationModel.js, TechStack.js, Contact.js).

public/: Static assets like images, SVGs, fonts.

hooks/: Custom React hooks for shared logic.

utils/: Utility functions.

Dependencies: Install necessary packages: react, react-dom, next, tailwindcss, postcss, autoprefixer, and your chosen animation library (e.g., gsap, framer-motion).

2. Code Quality & Modularity
   Clean Code: Write clean, readable, and self-documenting code.

Modularity: Break down complex UI into smaller, reusable components. Each component should have a single responsibility.

Comments: Add clear and concise comments for complex logic, function headers, and non-obvious implementations, especially for animations and scroll effects.

ESLint/Prettier: Consider setting up ESLint and Prettier for consistent code formatting and to catch common errors.

3. Styling with Tailwind CSS
   Utility-First: Embrace Tailwind's utility classes. Avoid writing custom CSS unless absolutely necessary (e.g., for very specific animations not achievable with utilities).

Responsive Design: Use Tailwind's responsive prefixes (sm:, md:, lg:, xl:) extensively to ensure the layout, typography, and spacing adapt seamlessly across all devices (mobile, tablet, desktop).

Customization: If needed, extend Tailwind's configuration (tailwind.config.js) for custom colors, fonts, or spacing.

Inter Font: Use "Inter" as the primary font unless specified otherwise.

4. Animations & Scroll UX
   Animation Library: Choose either GSAP + ScrollTrigger or Framer Motion. Both are excellent choices for the required scroll-based and subtle animations.

GSAP: Powerful for complex timeline-based animations and precise control over scroll-triggered effects.

Framer Motion: Integrates well with React, offering declarative animations and simpler syntax for many common effects.

Scroll UX: Implement Lenis or Locomotive Scroll for smooth, custom scroll experiences. This is key to achieving the "Neverhack.com" feel.

Performance: Optimize animations for smooth performance. Use will-change CSS property where appropriate, and avoid animating properties that trigger layout recalculations (e.g., width, height). Prefer transform and opacity.

Subtle Effects: Focus on subtle animations on load/scroll and hover/motion effects for icons/cards as specified.

3D/Graphics: If opting for 3D, consider Three.js for custom 3D scenes or Spline for simpler embedded 3D assets. For 2D graphics, SVG animations are highly encouraged for crispness and scalability.

5. Responsiveness & Optimization
   Mobile-First Approach: Design and develop with mobile devices in mind first, then progressively enhance for larger screens.

Viewport Meta Tag: Ensure <meta name="viewport" content="width=device-width, initial-scale=1.0"> is present in your HTML <head>.

Fluid Layouts: Use relative units (%, vw, vh, rem) and Tailwind's flexible box utilities (flex, grid, w-full, max-w-full) to create fluid layouts that adapt to screen size. Avoid fixed pixel widths for main layout elements.

Image Optimization: Optimize images (e.g., compress, use modern formats like WebP) to reduce load times.

Lazy Loading: Implement lazy loading for images and non-critical assets to improve initial page load performance.

6. Backend / API (Optional)
   Mock Backend/API: If you choose to implement the optional backend for the contact form, a simple Node.js express server or a mock API (e.g., JSONPlaceholder for testing) would suffice. Next.js API Routes can also be used for this.

Headless CMS: Alternatively, integrating with a headless CMS (like Strapi, Contentful, or Sanity) for content management can be a good demonstration of your skills, though it might be overkill for a simple assignment.

7. Deployment & Version Control
   Deployment: Plan to deploy your site on Vercel or Netlify. Both offer seamless integration with GitHub repositories. Vercel is particularly well-suited for Next.js projects.

GitHub Repository: Maintain a clean and well-organized GitHub repository.

Meaningful Commits: Use clear and descriptive commit messages.

README.md: Include a comprehensive README.md file explaining how to set up, run, and deploy the project, along with a brief overview of the tech stack and features.

Branching Strategy: Use a simple branching strategy (e.g., main for production, dev for ongoing work, feature branches for new features).

8. Creative Independence & Micro-interactions
   Thoughtful Design: While inspired by Neverhack, demonstrate your own creative independence in layout and design decisions.

Micro-interactions: Pay attention to small details like button hover states, subtle transitions on element appearance, and other micro-interactions that enhance the user experience.

SVG Animation: Leverage SVG for icons and illustrations, and explore animating them for crisp, scalable visual effects.

By following these guidelines, you'll be well-equipped to create a polished, performant, and impressive landing page for your assignment. Good luck!
Project Development Guidelines for AI SaaS Landing Page
This document outlines a set of best practices and "rules" to follow while developing your single-page landing site for an AI SaaS product, inspired by the provided assignment brief. Adhering to these guidelines will help ensure a high-quality, maintainable, and visually engaging solution.

1. Project Setup & Structure
   Framework: Utilize Next.js (App Router), which is an excellent choice for a modern React application, offering features like file-system based routing and server components.

Styling: Implement styling exclusively with Tailwind CSS. Leverage its utility-first approach for rapid and consistent styling, and its responsive prefixes (sm:, md:, lg:) for adaptive design.

Folder Structure: Maintain a clear and modular folder structure, typical for Next.js App Router projects.

app/: (This is your main application directory for the App Router)

layout.js: Root layout for your application.

page.js: Your main landing page component.

globals.css: Global styles, including Tailwind CSS imports.

components/: Reusable UI components (e.g., Button.js, Navbar.js).

sections/: Each of the five main sections of your landing page (e.g., Hero.js, WhoWeAre.js, TransformationModel.js, TechStack.js, Contact.js).

public/: Static assets like images, SVGs, fonts.

hooks/: Custom React hooks for shared logic.

utils/: Utility functions.

Dependencies: Install necessary packages: react, react-dom, next, tailwindcss, postcss, autoprefixer, and your chosen animation library (e.g., gsap, framer-motion).

2. Code Quality & Modularity
   Clean Code: Write clean, readable, and self-documenting code.

Modularity: Break down complex UI into smaller, reusable components. Each component should have a single responsibility.

Comments: Add clear and concise comments for complex logic, function headers, and non-obvious implementations, especially for animations and scroll effects.

ESLint/Prettier: Consider setting up ESLint and Prettier for consistent code formatting and to catch common errors.

3. Styling with Tailwind CSS
   Utility-First: Embrace Tailwind's utility classes. Avoid writing custom CSS unless absolutely necessary (e.g., for very specific animations not achievable with utilities).

Responsive Design: Use Tailwind's responsive prefixes (sm:, md:, lg:, xl:) extensively to ensure the layout, typography, and spacing adapt seamlessly across all devices (mobile, tablet, desktop).

Customization: If needed, extend Tailwind's configuration (tailwind.config.js) for custom colors, fonts, or spacing.

Inter Font: Use "Inter" as the primary font unless specified otherwise.

4. Animations & Scroll UX
   Animation Library: Choose either GSAP + ScrollTrigger or Framer Motion. Both are excellent choices for the required scroll-based and subtle animations.

GSAP: Powerful for complex timeline-based animations and precise control over scroll-triggered effects.

Framer Motion: Integrates well with React, offering declarative animations and simpler syntax for many common effects.

Scroll UX: Implement Lenis or Locomotive Scroll for smooth, custom scroll experiences. This is key to achieving the "Neverhack.com" feel.

Performance: Optimize animations for smooth performance. Use will-change CSS property where appropriate, and avoid animating properties that trigger layout recalculations (e.g., width, height). Prefer transform and opacity.

Subtle Effects: Focus on subtle animations on load/scroll and hover/motion effects for icons/cards as specified.

3D/Graphics: If opting for 3D, consider Three.js for custom 3D scenes or Spline for simpler embedded 3D assets. For 2D graphics, SVG animations are highly encouraged for crispness and scalability.

5. Responsiveness & Optimization
   Mobile-First Approach: Design and develop with mobile devices in mind first, then progressively enhance for larger screens.

Viewport Meta Tag: Ensure <meta name="viewport" content="width=device-width, initial-scale=1.0"> is present in your HTML <head>.

Fluid Layouts: Use relative units (%, vw, vh, rem) and Tailwind's flexible box utilities (flex, grid, w-full, max-w-full) to create fluid layouts that adapt to screen size. Avoid fixed pixel widths for main layout elements.

Image Optimization: Optimize images (e.g., compress, use modern formats like WebP) to reduce load times.

Lazy Loading: Implement lazy loading for images and non-critical assets to improve initial page load performance.

6. Backend / API (Optional)
   Mock Backend/API: If you choose to implement the optional backend for the contact form, a simple Node.js express server or a mock API (e.g., JSONPlaceholder for testing) would suffice. Next.js API Routes can also be used for this.

Headless CMS: Alternatively, integrating with a headless CMS (like Strapi, Contentful, or Sanity) for content management can be a good demonstration of your skills, though it might be overkill for a simple assignment.

7. Deployment & Version Control
   Deployment: Plan to deploy your site on Vercel or Netlify. Both offer seamless integration with GitHub repositories. Vercel is particularly well-suited for Next.js projects.

GitHub Repository: Maintain a clean and well-organized GitHub repository.

Meaningful Commits: Use clear and descriptive commit messages.

README.md: Include a comprehensive README.md file explaining how to set up, run, and deploy the project, along with a brief overview of the tech stack and features.

Branching Strategy: Use a simple branching strategy (e.g., main for production, dev for ongoing work, feature branches for new features).

8. Creative Independence & Micro-interactions
   Thoughtful Design: While inspired by Neverhack, demonstrate your own creative independence in layout and design decisions.

Micro-interactions: Pay attention to small details like button hover states, subtle transitions on element appearance, and other micro-interactions that enhance the user experience.

SVG Animation: Leverage SVG for icons and illustrations, and explore animating them for crisp, scalable visual effects.

By following these guidelines, you'll be well-equipped to create a polished, performant, and impressive landing page for your assignment. Good luck!
